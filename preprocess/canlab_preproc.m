function canlab_preproc(basedir, run_wildcard, image_wildcard, TR, struct_wildcard, varargin)
% canlab_preproc(basedir, run_wildcard, image_wildcard, TR, struct_wildcard, [options])
%
% This is the basic preprocessing function for fmri images.  It uses
% preproc_part1 and preproc_part2.  It will output files into a
% directory based on the child directory from basedir.  If images are
% stored as 4-D image files, make sure that only one image file is in each
% run directory, otherwise the code will assume that the images are
% actually 3-D.
%
%
% INPUT:
%   basedir:
%      the working directory that is common to all the necessary
%      files.  With the suggested set-up, this should be the
%      the subject's base directory directory
%   run_wildcard:
%      a string that indicates the set [*] of directories that
%      hold all the raw data to be processed. Must be located
%      in basedir/Functional/Raw/[*].  If there are multiple wilcards
%      in your run directory listing, make a char array where each row
%      is one of the required wildcards.  This feature only works with
%      up to two rows at the moment.
%      For example, ['run*'; 'APP*'] Note that both elements must be
%      the same length!  You can pad with spaces if necessary (i.e.
%      ['run*', 'A*  '], but do not use '*    ' -- you must have at
%      least one non-wildcard character or it will take the . and ..
%      directories as well, which is bad.
%   image_wildcard:
%      a string that indicates the raw files that should be processed
%   TR:
%      the TR of the scan, in seconds.
%   struct_wildcard:
%      a string that indicates the the set of structural
%      images.  can have two wildcards, i.e. '/APP*/*.nii'
%
% OPTIONS:
%   'nomovie':      no movie file is created
%   'nomean':       no mean image mask for spike analysis is generated
%   'nospikeid':	the spike analysis is not run
%   'nopart1':      preproc_part1 is not run. This assumes that it has
%                      been run in the past and that the *.mat file is
%                      located in the proper location so that it may be
%                      loaded properly.
%   'nosliceorder': ?????
%   'disdaqs':      the number of functional images at the beginning of
%                      a scan to discard.  The string should be followed by
%                      either a single integer that represents the number
%                      of disdaqs to remove from each run, or a column
%                      array that specifies how many disdaqs to remove from
%                      each individual run.  Removing disdaqs for 4D images
%                      requires FSL to run. Default value of disdaqs is 0.
%
%         **WARNING:** if disdaqs already happened, and you
%                      are re-running the data from a midway point, do NOT
%                      do disdaqs again!
%   'acquisition':  used to specify the acquisition type in the
%                      following string.  Possible choices are:
%
%      'interleaved_BU': Image acquisition was interleaved, bottom-up (Default)
%      'interleaved_TD': Image acquisition was interleaved, top-down
%      'ascending':      Image acquisition was in order, bottom to top
%      'descending':     Image acquisition was in order, top to bottom
%      'interleavedMT':  Image acquisition was interleaved, middle - top
%
% -------------------------------------------------------------------------
% OUTPUT:
%
% OUTPUT:
%
% Diagnostic files are output to qc_dir.
% Preprocessed files are output
%    to basedir/../Preprocessed.
%
% Images include:
%  * Implicit mask histogram:  intensity values of the image and the
%  implicit mask.  The values of the first 20 images are averaged and then
%  displayed in this histogram.  This is created in the function
%  fmri_mask_thresh_canlab.m.  Voxels with low values are likely out-of-brain
%  and will be excluded from the implicit mask.
%  * Implicit mask montage:  a picture of the implicit mask
%  * Mean mask before preproc:   This is the (fairly broad) mask used for
%  preprocessing.  It is a binary mask produced by taking all voxels whose
%  mean signal is in the top 80% of mean signal values (i.e., applying a
%  threshold of 80% to mean_func_before_preproc.img).  you can use
%  spm_check_registration(<filename>) to view this image.
%  * Motion params:  in the top left subplot, each line represents movement
%  in one direction (X, Y, or Z).
%  * Scn_session_spike:  this figure is generated by
%  scn_session_spike_id.m.  In the color bars, each point represents the
%  mean intensity or STD for a given slice at a given time/TR.  Values are
%  z-scored within slice.  A spike may be identifiable if a given image
%  (i.e. vertical column) is several standard deviations from other images.
%  Spikes are usually identified at the level of image rather than slice.
%  The bar graphs are generated by the function trimts.m, see the help
%  there for more information.  Each red vertical line representes an
%  identified spike
%  * Sources of variance:  This is generated in the inline function
%  summarize_multisession_output in scn_session_spike_id.m.  The total
%  variance in global signal is divided into spikes, linear trends, and
%  within-session error.
%  * FFT of unexplained global signal:  This is generated in the inline
%  function summarize_multisession_output in scn_session_spike_id.m.  It is
%  the FFT of the residual error, i.e. variance not due to spikes or linear
%  drift
%
% Examples:
% -------------------------------------------------------------------------
% canlab_preproc('/data/projects/wagerlab/labdata/current/PAL/Imaging/PALP2324', 'r*', '*run*nii', 'IM*dcm', 2);

% To-do: save motion params with rest
% and plot next to other measures of outliers.
% one mean image only for scn_spike_id
% omit interactive origin
%
% Now make non-interactive mode for publish
% file name loading separate
% build batch job
% warnings for SPM2/5
%
% Spike ID could combine motion, spikes, and successive differences
% single implicit mask, using fmri_data, and then plots/etc in object
% method
% then interpolate bad outliers

%% ------------------------------------------------------------------------
% Defaults
% -------------------------------------------------------------------------

writemovie = 1;
writemean = 1;
dospikeid = 1;
dopart1 = 1;
dopart2 = 1;
disdaqs = 0;
acq = 'interleaved_BU';
dointeractive = 1;

i=1;
while i<=length(varargin)
    if(ischar(varargin{i}))
        switch(varargin{i})
            case {'nomovie'}
                writemovie = 0;
            case {'nomean'}
                writemean = 0;
            case {'nospikeid'}
                dospikeid = 0;
            case {'nopart1'}
                dopart1 = 0;
            case {'disdaqs','disdaq'}
                i=i+1;
                disdaqs = varargin{i};
            case 'nointeractive'
                dointeractive = 0;
                
            case {'acquisition'}
                i=i+1;
                switch varargin{i}
                    case {'interleaved_BU','interleaved_TD','ascending','descending','interleavedMT'}
                        acq = varargin{i};
                    otherwise
                        error(['Unrecognized option to ''acquisition'': ' varargin{i}]);
                end
            otherwise
                error(['Unknown input string option: ' varargin{i}]);
        end
    end
    i=i+1;
end

%% -------------------------------------------------------------------------
% Set up runs and image names
% -------------------------------------------------------------------------
%check if the base directory is valid
if ~exist(basedir, 'dir'), error([basedir ' does not exist!']); end


cd(basedir)

%create a directory for quality control images
qcdir = fullfile(basedir, 'qc_images');
if ~exist(qcdir, 'dir'), mkdir(qcdir); end

logfilename = fullfile(qcdir, 'preprocessing_log.txt');

diary(logfilename)
spm_ver = spm('ver');

fprintf('Running for basedir = %s\n', basedir)
fprintf('Saving in file: %s\n', logfilename)
fprintf('Running the following version of SPM: %s\n',spm_ver);
fprintf('\n');


% basedir
% run_wildcard
% image_wildcard
% get_run_dirs(basedir, run_wildcard)


%% -------------------------------------------------------------------------
% List files and print
% -------------------------------------------------------------------------

numcards = size(run_wildcard, 1);

% establish each directory that has data

if numcards == 0  % No run wildcards; files are in raw directly
    error('You must place files in separate run subdirectories.');
    
elseif numcards == 1
    rundirs = dir(fullfile(basedir, 'Functional', 'Raw', run_wildcard));
else if numcards == 2
        smalldirs = dir(fullfile(basedir, 'Functional', 'Raw', deblank(run_wildcard(1,:))));
        smallnum = numel(smalldirs);
        tempdirs = dir(fullfile(basedir, 'Functional', 'Raw', smalldirs(1).name, deblank(run_wildcard(2,:))));
        smallernum = numel(tempdirs);
        rundirs = [];
        for n = 1:smallnum
            rundirs = [rundirs; dir(fullfile(basedir, 'Functional', 'Raw', smalldirs(n).name, deblank(run_wildcard(2,:))))]; %#ok
            for j = 1:smallernum
                rundirs(j+smallernum*(n-1)).name = fullfile(smalldirs(n).name,rundirs(j+smallernum*(n-1)).name);
            end
        end
    end
end

% eliminate selections that are not directories (i.e. files)
isnotdir = ~cat(1, rundirs.isdir);

if all(isnotdir)
    disp('Found no valid run directories.')
    searchin = fullfile(basedir, 'Functional', 'Raw', run_wildcard);
    fprintf('Searching in: %s\n', basedir);
    fprintf('Basedir: %s\nrun_wildcard: %s\n', basedir, run_wildcard);
    fprintf('Example of where files should be based on inputs:\n')
    fprintf('%s\n', fullfile(basedir, 'Functional', 'Raw', run_wildcard));
    return
end

rundirs(isnotdir) = [];


%ignore empty directories
ndirs = length(rundirs);
[temp_imgs, temp_wildcard] = deal(cell(ndirs, 1));
toremove = zeros(ndirs,1);
tokeep = zeros(ndirs,1);
for i = 1:ndirs
    temp_wildcard{i} = fullfile(basedir, 'Functional','Raw',rundirs(i).name, image_wildcard);
    temp_imgs{i} = filenames(temp_wildcard{i}, 'char', 'absolute');
    if size(temp_imgs{i},1) == 0
        toremove(i) = 1;
    else
        tokeep(i) = 1;
    end
end

toremove = find(toremove);
tokeep = find(tokeep);
fprintf('Found %3.0f run (session) directories:\n', numel(tokeep));
fprintf('Ignored %3.0f empty directories:\n', numel(toremove));

%calculate the number of separate runs
rundirs = rundirs(tokeep);
dirnames = char(rundirs(:).name);
nruns = length(rundirs);

%create image variables with placeholders
n_images_per_run = zeros(nruns, 1);
[imgs, img_wildcard] = deal(cell(nruns, 1));
str4d = cell(1, length(rundirs));

% if nruns == 0
%     disp('Found no valid runs.')
%     searchin = fullfile(basedir, 'Functional','Raw',rundirs(i).name, image_wildcard);
%     fprintf('Searching in, e.g.,:\n%s\n', searchin);
%     return
% end

% -------------------------------------------------------------------------
% List files and remove disdaqs if called for
% -------------------------------------------------------------------------

for i = 1:nruns
    % get filenames
    %this is the image locations in wildcard format
    img_wildcard{i} = fullfile(basedir, 'Functional','Raw', rundirs(i).name, image_wildcard);
    
    % filenames is Wagerlab SCN toolbox function
    % create a char matrix with all image paths
    imgs{i} = filenames(img_wildcard{i}, 'char', 'absolute');
    
    if isempty(imgs{i})
        disp('Run %3.0f: Found no images!', i)
        fprintf('Looking in:\n%s\n', img_wildcard{i});
    end
    
    % If 4-D images, then print size of file and number of volumes (3-D
    % acquisitions)
    if size(imgs{i},1) == 1
        % assume 4-D
        str4d{i} = '4-D images';
        n_images_per_run(i) = scn_num_volumes(imgs{i});
    else
        str4d{i} = '3-D images';
        n_images_per_run(i) = size(imgs{i},1);
    end
    
    % Remove disdaqs from analyzed data and move to a separate folder
    if disdaqs
        %parse disdaq info
        if numel(disdaqs)==1
            num_disdaqs = disdaqs;
            num_vols = n_images_per_run(i) - disdaqs;
        elseif size(disdaqs) == size(n_images_per_run)
            num_disdaqs = disdaqs(i);
            num_vols = n_images_per_run(i) - disdaqs(i);
        else
            error('The size of disdaqs is not the same as the number of runs')
        end
        
        % remove acquisitions from 4-D or 3-D image sets
        if strcmp(str4d{i},'4-D images')  %remove 4D disdaqs
            d_imgs = remove_disdaq_vols(imgs(i),num_vols,num_disdaqs);
            [d f e] = fileparts(imgs{i});
            if ~exist(fullfile(d,'disdaqs'),'dir')
                mkdir(fullfile(d,'disdaqs'));
            end
            movefile(imgs{i},fullfile(d,'disdaqs',[f e]))
            imgs{i} = expand_4d_filenames(d_imgs);
        else  %remove 3D disdaqs
            d = fileparts(imgs{i}(1,:));
            if ~exist(fullfile(d,'disdaqs'),'dir')
                mkdir(fullfile(d,'disdaqs'));
            end
            
            for n = 1:num_disdaqs %assume they're in order, and the top ones are earliest.
                [d f e] = fileparts(imgs{i}(n,:));
                movefile(imgs{i}(n,:),fullfile(d,'disdaqs',[f e]));
            end
            
            %update imgs to exclude disdaqs
            imgs{i} = imgs{i}((num_disdaqs+1):end,:);
            
        end
    else
        num_disdaqs = 0;
        if strcmp(str4d{i},'4-D images')
            imgs{i} = expand_4d_filenames(imgs{i});
        end
    end
    n_images_per_run(i) = size(imgs{i}, 1);
    
    fprintf('Run %3.0f:\t%s\t%3.0f images\t%3.0f discarded\t%s\n', i, str4d{i}, n_images_per_run(i), num_disdaqs, img_wildcard{i});
    
end % nruns

% -------------------------------------------------------------------------
%%% get the anatomical ready for part 2
% -------------------------------------------------------------------------

if dopart2
    struct_dir_path = fullfile(basedir,'Structural', 'SPGR', struct_wildcard);
    anat = filenames(struct_dir_path);
    
    % There should only be one anatomical file here.
    % If there are multiple structurals, average them before running this.
    % You will have to deal with multiple structurals separately until we edit
    % the code.
    % For ex: for multiple structs on diff days, 1) coreg all structs to one
    % another.  2) Make a mean (if same image type, e.g., T1) and use that mean
    % in canlab_preproc.m.  3) After preproc part 2, the mean T1 will be
    % coregistered, so you need to coreg (mutual info!!) all the other structurals to that one.
    
    %the anat file
    if (size(anat, 1) > 1)
        warning('THIS CODE ONLY SUPPORTS ONE SINGLE ANATOMICAL FILE NOW.\nTo handle multiple structurals, For ex: for multiple structs on diff days\n');
        warning('\t1) coreg all structs to one\n');
        warning('\t2) Make a mean (if same image type, e.g., T1) and use that mean in canlab_preproc.m.\n');
        warning('\t3) After preproc part 2, the mean T1 will be coregistered, so you need to coreg (mutual info!!) all the other structurals to that one.\n\n');
        warning('\tOnly the first anatomical file will be used, THE EXTRAS WILL BE IGNORED!\n')
    elseif (size(anat, 1) < 1)
        fprintf('Looking for anatomical in:\n%s\n]', struct_dir_path);
        disp(['No anatomical files found using wildcard: ' struct_wildcard])
        error('Directory structure does not conform to CANlab standards or files are missing .')
    end
end % setup anat

diary off

try
    snapnow
catch
    warning('Error executing snapnow.  Old version of Matlab??');
end


%% -------------------------------------------------------------------------
% Movie of montages
% -------------------------------------------------------------------------

if writemovie || writemean
    
    dat = fmri_data(char(imgs{:}));
    
end

% Write output movie
% improvements: 1) use slover? 2) print to gif?

% myslover = struct('func', 'i1(i1==0)=NaN', 'vol', spm_vol(imgs{1}(1, :)), 'hold', 1);
% myslover = slover(imgs{1}(1, :))
% slover(myslover)

if writemovie
    
    % Movie of successive differences (sagittal slice)
    % ------------------------------------------------------
    
    movieoutfile = fullfile(qcdir, 'slice_movie.tiff');
    
    sagg_slice_movie(dat, movieoutfile);
    
    
    % OLD style
    %     movieoutfile = fullfile(qcdir, 'slice_movie.tiff');
    %     skipby = 5;
    %
    %     han = montage_clusters(imgs{1}(1, :));
    %     figure(han);
    %
    %     for r = 1:length(imgs)
    %         for i = 1:skipby:size(imgs{r}, 1)
    %
    %             han = montage_clusters(imgs{r}(i, :));
    %             hh = get(han, 'Children'); hh = findobj(hh, 'Type', 'Axes');
    %             axes(hh(hh==min(hh))); %#ok<LAXES>
    %             title(['Run ' num2str(r) ' Image ' num2str(i)]);
    %
    %             figure(han); drawnow;
    %             F = getframe(gcf);
    %
    %             if r == 1 && i == 1
    %                 imwrite(F.cdata, movieoutfile,'tiff', 'Description', img_wildcard{1}, 'Resolution', 30);
    %             else
    %                 imwrite(F.cdata, movieoutfile,'tiff', 'WriteMode', 'append', 'Resolution', 30);
    %             end
    %         end
    %     end
    
end

try
    snapnow
catch
    warning('Error executing snapnow.  Old version of Matlab??');
end

%% -------------------------------------------------------------------------
% Create and threshold mean image; plot
% NOTE: SPIKE ID NO LONGER NEEDS/USES THIS
% -------------------------------------------------------------------------
meanfilename = fullfile(basedir,'Functional','Raw','mean_func_before_preproc.img');
meanmaskname = fullfile(qcdir, 'mean_mask_before_preproc.img');

if writemean
    % montage of mean image
    saveimagename = fullfile(qcdir, 'mean_image_montage.png');
    saveimagenameo = fullfile(qcdir, 'mean_image_atorigin.png');
    %     saveimagenameo2 = fullfile(qcdir, 'mean_image_atmarker.png');
    
    %mean_image(char(imgs{:}), meanfilename);
    % dat = fmri_data(char(imgs{:})); % done earlier
    
    mm = mean(dat);
    mm.fullpath = meanfilename;
    write(mm);
    
    spm_image('init', meanfilename);
    spm_orthviews('reposition', [0 0 0]);
    saveas(gcf, saveimagenameo);
    
    try
        snapnow
    catch
    end
    
    % han = montage_clusters(meanfilename);
    % saveas(gcf, saveimagename);
    
    cluster_orthviews_montage(10, 'axial', [], 'onerow');
    fh = findobj('Tag', 'Graphics');
    set(fh, 'Visible', 'off');
    fh = findobj('Tag', 'montage_axial');
    figure(fh);
    %set(fh,'Renderer','zbuffer')
    scn_export_papersetup(300);
    saveas(fh, saveimagename);
    
    %
    %     if dointeractive
    %         input('Click on vitamin e capsule marker and press return: ','s');
    %         saveas(gcf, saveimagenameo2);
    %     end
    % rough mask - no longer needed due to implicit mask
    %     V = spm_vol(meanfilename); dat = spm_read_vols(V); thr = prctile(dat(:), 20);
    %     spm_imcalc_ui(meanfilename, meanmaskname,['i1 > ' num2str(thr)])
    
end

try
    snapnow
catch
    warning('Error executing snapnow.  Old version of Matlab??');
end

%% -------------------------------------------------------------------------
% Outlier analysis: scn spike id
% -------------------------------------------------------------------------
% scn spike id

% if dospikeid && ~writemean
%     error('You must use the default write-mean option if you want to do spike ID.');
% end

if dospikeid
    spikeidimgs = {};
    
    for i = 1:numel(imgs)
        funcimg = nifti(imgs{i});
        if funcimg.dat.dim(4) <= 2 * funcimg.dat.dim(3)
            warnstr = sprintf('The following image will not be run through scn_session_spike_id:\n(it has fewer volumes than twice the number of slices)\n%s',imgs{i});
            warning(warnstr)
        else
            spikeidimgs{end+1} = imgs{i};
        end
    end
    
    spikeidoutname = fullfile(qcdir, 'scn_session_spike_id_output.mat');
    diary(logfilename)
    
    %if publishspikeid
    %     SUBJDATA.study = input('Enter study code (case sensitive: )', 's');
    %
    %     [tmp, subjname] = fileparts(basedir);
    %     SUBJDATA.subject = subjname;
    %
    %     SUBJDATA.html_save_dir = fullfile(qcdir, 'html_output');
    %     SUBJDATA.subject_dir = basedir;
    %
    %     inputimgs = imgs;
    %     publish_scn_session_spike_id(inputimgs, SUBJDATA);
    
    % use implict mask, not mean...
    [g, spikes, gtrim, nuisance_covs, spikesperimg, snr] = scn_session_spike_id(spikeidimgs); %, meanmaskname);  %#ok<ASGLU,NASGU>
    
    save(spikeidoutname, 'g', 'spikes', 'gtrim', 'nuisance_covs', 'spikesperimg', 'snr')
    
    diary off
    
end

try
    snapnow
catch
    warning('Error executing snapnow.  Old version of Matlab??');
end

%% -------------------------------------------------------------------------
% Preproc Part 1
% -------------------------------------------------------------------------
preprocdir = fullfile(basedir, 'Functional', 'Preprocessed');
if ~exist(preprocdir, 'dir')
    mkdir(preprocdir);
end
preprocmatname = fullfile(preprocdir, 'PREPROC_SETUP.mat');

if dopart1
    diary(logfilename)
    disp('_______________________________________________');
    disp('Running preproc_part1: Slice timing, realignment');
    disp(['Using' acq ' acquisition']);
    disp('_______________________________________________');
    
    fprintf('Saving PREPROC setup structure with image names, etc., in file: \n%s\n', preprocmatname)
    
    if ~exist('TR', 'var') || isempty(TR)
        TR = input('Enter TR in sec: ');
    end
    
    PREPROC = struct('basedir', basedir, 'logfilename', logfilename, 'run_wildcard', run_wildcard, ...
        'image_wildcard', image_wildcard, 'dirnames', dirnames,  ...
        'meanfilename', meanfilename, 'meanmaskname', meanmaskname, ...
        'qcdir', qcdir, 'TR', TR, 'num_vols_per_run', n_images_per_run, 'anat', anat);
    
    PREPROC.str4d = str4d;
    PREPROC.rundirs = rundirs;
    PREPROC.func_files = imgs;
    
    PREPROC.run_dir_base = []; % preprocdir;  % could do this to move files, but need to debug in preproc_part1
    
    if exist(preprocmatname, 'file')
        save(preprocmatname, '-append', 'PREPROC')
    else
        save(preprocmatname, 'PREPROC')
    end
    
    PREPROC = preproc_part1(PREPROC, ...
        'slice timing', 1, 'motion correction', 1, 'local', 0, ...
        'verbose', 1, 'clean_up', 1, 'save plots', 0, spm_ver, ...
        'movie', 0, 'mean func', 1, 'run_dir_base', PREPROC.run_dir_base, 'acquisition', acq);
    
    fprintf('Saving PREPROC setup structure with UPDATED avol and ravol image names in: \n%s\n', preprocmatname)
    save(preprocmatname, '-append', 'PREPROC')
    
    diary off
    
    % Save motion parameter figures
    try
        f1 = findobj('Type', 'Figure', 'Tag', 'Graphics');
        figure(f1); scn_export_papersetup(700)
        saveas(gcf, fullfile(qcdir, 'motion_param.png'));
    catch
        warning('Error saving motion param figure.');
    end
    
    % Save motion parameter figures
    try
        f1 = findobj('Tag', 'Data Detail');
        figure(f1); scn_export_papersetup(700)
        saveas(gcf, fullfile(qcdir, 'motion_param_globals_scnlab.png'));
    catch
        warning('Error saving motion param scnlab figure.');
    end
    
    %     %remove unneccesary files         %too soon?
    %     [dummy,dummy,e] = fileparts(imgs{1}(1,:));
    %     for n = 1:numel(PREPROC.rundirs)
    %         canlab_remove_images(PREPROC.rundirs(1,:),['a*.' e]);
    %     end
end

try
    snapnow
catch
    warning('Error executing snapnow.  Old version of Matlab??');
end


%% Preproc Part 2
if dopart2
    load(fullfile(basedir, 'Functional', 'Preprocessed','PREPROC_SETUP.mat'));
    
    if ~exist('PREPROC', 'var')
        disp('PREPROC structure is missing. It likely did not save correctly or was overwritten.');
        return
    end
    
    if ~exist('anat','var')
        anat = PREPROC.anat;
    end
    
    % THE FOLLOWING TEST IS PERFORMED IN THE List files and print SECTION
    % WHEN RUNNING PART1. IT IS REPEATED HERE AS A REMINDER TO THE USER
    if (size(anat, 1) > 1)
        warning('THIS CODE ONLY SUPPORTS ONE SINGLE ANATOMICAL FILE NOW.\nTo handle multiple structurals, For ex: for multiple structs on diff days\n');
        warning('\t1) coreg all structs to one\n');
        warning('\t2) Make a mean (if same image type, e.g., T1) and use that mean in canlab_preproc.m.\n');
        warning('\t3) After preproc part 2, the mean T1 will be coregistered, so you need to coreg (mutual info!!) all the other structurals to that one.\n\n');
        warning('\tOnly the first anatomical file will be used, THE EXTRAS WILL BE IGNORED!\n')
    end
end

%if part2 has already run, then the load command above loaded PREPROC2.  Since this already has the correct values,
%we can and should skip the initialization of PREPROC2 in the block below.
if ~exist('PREPROC2', 'var')
    if iscell(anat)
        PREPROC2.anat_files = anat{1};
    else
        PREPROC2.anat_files = anat;
    end
    
    % the mean ra func file.  remove trailing comma and number and deblank
    meanfunc = fullfile(basedir, PREPROC.meanfilename_realigned);
    wh_comma = find(meanfunc == ',');
    if ~isempty(wh_comma) % take off the comma, if exists
        meanfunc = meanfunc(1:wh_comma - 1);
    end
    PREPROC2.mean_ra_func_files = deblank(meanfunc);
    PREPROC2.files_to_warp = PREPROC.realigned_func_files; % files_to_warp: Apply origins and warps to these files.
    PREPROC2.files_to_warp = {char(PREPROC2.files_to_warp)};
    
else % PREPROC2 has (mostly) correct values.  If this file is old, may need to be corrected!
    fprintf('Length of PREPROC2.files_to_warp: %d \n', length(PREPROC2.files_to_warp{1})); %output variable contents
    fprintf('Confirm that ALL the images (not only first run) are in PREPROC2.files_to_warp{1}  (length is displayed above)\n');
    fprintf('If they are not (because this subject was initially preprocessed with an older version of this code), you must\n');
    fprintf('Run this line in the command window now:  PREPROC2.files_to_warp{1} = vertcat(PREPROC2.files_to_warp{:})\n');
    fprintf('If/when the data is OK, type "return" and hit enter to continue\n');
    keyboard;
end

preproc_part2(PREPROC2);
if exist(preprocmatname, 'file')
    save(preprocmatname, '-append', 'PREPROC2')
else
    save(preprocmatname, 'PREPROC2')
end

try
    snapnow
catch
    warning('Error executing snapnow.  Old version of Matlab??');
end

%% move the ra wra and swra vols to "Preprocessed and delete the a_vols

% CONSIDER USING: function output_names = copy_image_files(image_list,
% to_dir, ['method'], varargin)

%move the functional images
for i = 1:nruns
    if ~exist(fullfile(basedir,'Functional','Preprocessed',rundirs(i).name),'dir')
        mkdir(fullfile(basedir,'Functional','Preprocessed',rundirs(i).name))
    end
    
    % delete a vols
    todel_wildcard{i} = fullfile(basedir, 'Functional','Raw',rundirs(i).name,'a*.*');
    delete(todel_wildcard{i});
    delete(fullfile(basedir, 'Functional','Raw',rundirs(i).name,'a*.mat'));
    
    % move ra, wra, swra vols and mat files
    tomove_wildcard{i} = fullfile(basedir, 'Functional','Raw',rundirs(i).name, ['*ra*.*']);
    tomove{i} = filenames(tomove_wildcard{i},'char','absolute');
    txt{i} = filenames(fullfile(basedir, 'Functional','Raw',rundirs(i).name,'rp*.txt'),'char','absolute');
    mats{i} = filenames(fullfile(basedir,'Functional','Raw',rundirs(i).name,'ra*.mat'),'char','absolute');
    
    for n = 1:size(tomove{i},1)
        [dummy, f, e] = fileparts(tomove{i}(n,:));
        movefile(strtrim(tomove{i}(n,:)),fullfile(basedir,'Functional','Preprocessed',rundirs(i).name,[f e]));
    end
    
    mats{i} = filenames(fullfile(basedir,'Functional','Raw',rundirs(i).name,'ra*.mat'),'char','absolute');
    for n = 1:size(mats{i},1)
        [junk, mtf, mte] = fileparts(mats{i}(n,:));
        movefile(strtrim(mats{i}(n,:)),fullfile(basedir,'Functional','Preprocessed',rundirs(i).name,[mtf mte]));
    end
    
    %[dummy, txf, txe] = fileparts(txt{i});
    
    txt{i} = filenames(fullfile(basedir, 'Functional','Raw',rundirs(i).name,'*.txt'),'char','absolute');
    
    for n = 1:size(txt{i}, 1)
        myfile = deblank(txt{i}(n, :));
        [junk, txf, txe] = fileparts(myfile);
        movefile(myfile,fullfile(basedir,'Functional','Preprocessed',rundirs(i).name,[txf txe]));
    end
    
end

%% List filenames in structure for late use
% Check that files exist, and save PREPROC structure
% -------------------------------------------------------------------------
[tomove_wildcard, PREPROC.slice_time_corr_func_files, PREPROC.realigned_func_files, PREPROC.wra_func_files, PREPROC.swra_func_files, PREPROC.mvmt_param_files, allnames] = deal({});

for i = 1:nruns
    
    tomove_wildcard{i} = fullfile(basedir, 'Functional', 'Preprocessed', rundirs(i).name, ['*.*']);
    allnames{i} = filenames(tomove_wildcard{i},'char','absolute');
    
    %allnames{i} = char([tomove{i}; mats{i}; txt{i}]);
    
    for n = 1:size(allnames{i},1)
        
        myfile = deblank(allnames{i}(n, :));
        [dummy, f, e] = fileparts(myfile);
                
        if strcmp(e, '.txt') && strcmp(f(1:2), 'rp')
            % realignment params
            PREPROC.mvmt_param_files{i, 1} = myfile;
            
        elseif strcmp(e, '.img') || strcmp(e, '.nii')
            
            myfile = check_valid_imagename(myfile, 0);
            if isempty(myfile)
                disp('canlab_preproc warning!!! File does not exist, and it should:');
                fprintf('%s\n', myfile);
                continue
            end
            
            switch f(1)
                case 'a'  % avol - should not happen...
                    PREPROC.slice_time_corr_func_files{i, 1} = myfile;
                case 'r'  % ravol
                    PREPROC.realigned_func_files{i, 1} = myfile;
                case 'w'  % wravol
                    PREPROC.wra_func_files{i, 1} = myfile;
                case 's'  % swravol
                    PREPROC.swra_func_files{i, 1} = myfile;
            end 
            
        end % if
        
    end % for file
    
end


save(fullfile(basedir, 'Functional', 'Preprocessed', 'PREPROC_SETUP.mat'), '-append', 'PREPROC')

disp('======================================================================================');
disp('=                                                                                    =');
disp('= Saved names of ra, wra, swra image files                                           =');
disp('= in PREPROC_SETUP.mat in PREPROC variable.                                          =');
disp('=                                                                                    =');


%%
%move the structurals
%to make it easy, move the raw file, then move everything in the directory, then put it back.
%(if all functional images were 4D, could have done it this way as well)
% if ~exist(fullfile(basedir,'Structural','Preprocessed'),'dir')
%     mkdir(fullfile(basedir,'Structural','Preprocessed'))
% end
% [dummy,f,e] = fileparts(anat{1});
% mkdir(fullfile(basedir,'TEMP'))
% movefile(strtrim(anat{1}),fullfile(basedir,'TEMP',[f e]));
% proc_mats = filenames(fullfile(basedir,'Structural','Raw','*.mat'));
% proc_imgs = filenames(fullfile(basedir,'Structural','Raw','*.nii'));  %put an optional variable type save here?
% proc_structs = cat(1,proc_mats,proc_imgs);
% for n = 1:size(proc_structs,1)
%     [junk,stf,ste] = fileparts(proc_structs{n});
%     movefile(strtrim(proc_structs{n}),fullfile(basedir,'Structural','Preprocessed',[stf ste]))
% end
% movefile(strtrim(fullfile(basedir,'TEMP',[f e])),anat{1});
% rmdir(fullfile(basedir,'TEMP'));

%move mean images  -assumes .nii image, could make that optional later
% not moving these so part2 can run again and knows where to find the files
%movefile(strtrim(fullfile(basedir,'mean_ra_func.*')),fullfile(basedir,'Functional','Preprocessed','mean_ra_func.*'));
%movefile(strtrim(fullfile(basedir,'wmean_ra_func.*')),fullfile(basedir,'Functional','Preprocessed','wmean_ra_func.*'));
%movefile(strtrim(fullfile(basedir,'Functional','Raw','mean_wra_func.*')),fullfile(basedir,'Functional','Preprocessed','mean_wra_func.*'));

%% html showing output files in directory and labels that describe what they are
% canlab_html_creator(basedir,'preproc')

try
    snapnow
catch
    warning('Error executing snapnow.  Old version of Matlab??');
end

disp('= CANLAB_PREPROC done.                                                               =');
disp('=                                                                                    =');
disp('======================================================================================');

end  % main function

