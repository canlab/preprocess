function matlabbatch = canlab_spm_fmri_model_job(subjoutputdir, TR, hpfilterlen, images_by_run, conditions_per_run, onsets, durations, names, multi_nuisance_matfilenames, varargin)
%
% matlabbatch = canlab_spm_fmri_model_job(subjoutputdir, TR, hpfilterlen, images_by_run, conditions_per_run, onsets, durations, names, multi_nuisance_matfilenames, [optional inputs])
%
% Tor Wager and Wani Woo, Feb 2011
%
% Inputs:
% - Inputs for onsets, durations, names, nuisance regressor mat files are
% all specified the same way as they would be if you were using SPM's GUI
% and entering multiple conditions and a mat file with multiple regressors.
% - See spm_mat2batchinput.m for an easy way to extract this info from an
% existing SPM first-level directory
%
%       images_by_run: cell array, one cell per run.  Each cell array is
%       itself a cell array of filenames (i.e. as is generated by cellstr
%       function) (allows filenames can be of varying length)
%
%       conditions per run: vector specifying how many conditions of interest are in each
%       run.  I.e., [3 2 2] means that that the first run has 3 conditions,
%       the second run has 2 conditions, and the third run has 2
%       conditions.
%
%       onsets/durations:  cell array of onsets and durations vectors.  One cell per condition.  If
%       there are 7 conditions total across all runs, pass in a cell array
%       with 7 cells. No need to separate by run. ENTER VALUES IN SECONDS (not
%       TRs/images).
%
%       names: cell array, each cell has a string.  One cell per condition.
%       Same format as onsets/durations in that no need to separate by run.
%
%       multi_nuisance_matfilenames: cell array of file names.  one
%       cell/filename per run.  this file must contain a variable named R.  R is a matrix
%       with the nuisance regressors for given run.
%
% Options:
% 'is4d' : Specify that filenames in images_by_run are 4D files. It will
%           expand them into 3-D volumes (takes time).
%           This function assumes they are 4D if there is only one image
%           per run and will attempt to expand automatically in that case.
%
% 'notimemod' : turn off time modulation (default is ON)
% 'pmod' : add parametric modulators (default is no parametric modulator; see below)
% 'fmri_t', microtime_resolution (default: see spm_defaults (typically 16))
% 'fmri_t0', microtime_onset (default: see spm_defaults (typically 1))
% 'ar1': use autoregressive AR(1) to model serial correlations
%
% Convolution options:
% DEFAULT: HRF convolution with no derivatives.
% 'hrf', <1|0 time derivatives flag>, <1|0 dispersion derivatives flag>
%    SPM can add time and/or dispersion derivatives to HRF convolutions
%    EX: canlab_spm_fmri_model_job(..., 'hrf', 1, 0,...)
% 'fir', <length>, <order>
%    Use FIR covolution with conditions instead of HRF
%    (see SPM for description of length and order parameters)
%    EX: canlab_spm_fmri_model_job(..., 'fir', 1.9, 16)
%
% 
%
% Examples:
%
% conditions_per_run = repmat(4, 1, 8); % 4 conditions in each of 8 runs
% matlabbatch = canlab_spm_fmri_model_job(modeldir, TR, 180, imgs_by_session, conditions_per_run, onsets, durations, names, nuisance);
% spm_jobman('run', matlabbatch);
%
% NOTES:
% - default is to add linear time modulation. This may be more sensible
% in a 'single session' design; you can turn it off.
% - default is no autocorrelation
% - default is to model conditions as separate sessions (a future update
%       could allow this function to build a single-session version
%       automatically)
% - default is no parametric modulator 
%       you can add parametric modulators using 'pmod' varargin. pmod must have the same number of cells that have pmod struct in them. 
%       e.g., canlab_spm_fmri_model_job(..., 'pmod', pmod)
%       pmod is a cell array. you must have one cell per condition.  Each
%       cell is a struct with the fields name (the name of the modulator),
%            param (array of values, must be same length as condition
%            onsets/durations), and poly, which is an integer (i.e. 1)
%       if you want a modulator on only some of your conditions, pass in an
%       empty struct with the above fields for the other conditions.
%             e.g., pmod{1} = struct('name',{'cur_temp','prev_temp'},'param',{cur_temp(:,i),prev_temp(:,i)},'poly',{1,1});
%             e.g., pmod{2} = struct('name',{'time'},'param',{time(:,i)},'poly',{1});
% - contrasts and/or results should be added in a separate, later script
% - check SPM defaults for maxmem, flipping, and masking options (mask threshold may need to be adjusted for true explicit masking)
% - The default value of 128 sec for the HP filter is often not
%       appropriate, particularly for pain studies.
% - Optional inputs could easily be added to allow user-specified
%       autocorrelation, basis sets
%
% - Once you have created it, save it in a .mat file in the analysis
%       directory and then run it like this:
%       save(fullfile(modeldir, 'spm_model_spec_estimate_job.mat'), 'matlabbatch');
%       spm_jobman('run', matlabbatch);
%
% - After running, check the design using:
%       scn_spm_design_check(modeldir, 'events_only');
%
% - For contrast specification/estimation, see:
%   canlab_spm_contrast_job

% Programmers' notes:
% 7/2012 : Tor added code to remove trailing blanks in file image names,
% because it was causing files to not load in job manager!
% 9/2012 : Luka added microtime resolution and onset options
% 2/2013 : Luka added option to add derivatives, or sub FIR for HRF

is4d = any(strcmp(varargin, 'is4d'));

% default
timemod = 1;
pmodstruct = struct('name', [], 'param', [], 'poly', []);
pmodstruct = pmodstruct([]);
fmri_t = 16; % CANLAB
fmri_t0 = 1; % CANLAB
cvi = 'none'; % CANLAB DEFAULT: no autocorrelation modeling (i.e., no AR(1))

% varargin
i=1;
while i <= length(varargin)
    if(ischar(varargin{i}))
        switch(varargin{i})
            case {'notimemod'}
                timemod = 0;
            case {'pmod'}
                clear pmodstruct;
                i=i+1; pmodstruct = varargin{i};
            case 'is4d' % suppress warning; already handled
            case 'fmri_t'
                i=i+1; fmri_t = varargin{i};
            case 'fmri_t0'
                i=i+1; fmri_t0 = varargin{i};
            case 'hrf'
                bases.hrf.derivs = [varargin{i+1} varargin{i+2}];
                i=i+2;
            case 'fir'                
                i=i+1; bases.fir.length = varargin{i};
                i=i+1; bases.fir.order = varargin{i};
            case {'ar1' 'AR1'}
                cvi = 'AR(1)';
            otherwise
                error('canlab:varargin',['Unknown input string option: ' varargin{i}]);
        end
    else
        disp(varargin{i})
        error('canlab:varargin','Above argument is unrecognized.')
    end
    
    i=i+1;
end

if ~exist('bases','var')
    bases.hrf.derivs = [0 0];
end
    
% Directory
% -------------------------------------------------------------------------

matlabbatch{1}.spm.stats.fmri_spec.dir = {subjoutputdir}; % modeldir


% Timing
% -------------------------------------------------------------------------

matlabbatch{1}.spm.stats.fmri_spec.timing.units = 'secs'; % or 'scans'
matlabbatch{1}.spm.stats.fmri_spec.timing.RT = TR; %***
matlabbatch{1}.spm.stats.fmri_spec.timing.fmri_t = fmri_t; % CANLAB
matlabbatch{1}.spm.stats.fmri_spec.timing.fmri_t0 = fmri_t0; % CANLAB


% Images (scans)
% -------------------------------------------------------------------------

for j = 1:length(images_by_run) % from run1 to the last run
    
    imgs = images_by_run{j};
    
    if is4d || size(imgs, 1) == 1
        
        imgs = expand_4d_filenames(imgs); % expand to volumes if necessary
        
    end
    
    if iscell(imgs)
        matlabbatch{1}.spm.stats.fmri_spec.sess(j).scans = imgs;
    elseif ~iscell(imgs)
        imgs_cell = mat2cell(imgs, ones(size(imgs, 1), 1), size(imgs, 2));
        matlabbatch{1}.spm.stats.fmri_spec.sess(j).scans = imgs_cell;
    end
    
    % Make sure there are no trailing blanks - will prevent from loading correctly
    for i = 1:length(matlabbatch{1}.spm.stats.fmri_spec.sess(j).scans)
        matlabbatch{1}.spm.stats.fmri_spec.sess(j).scans{i} = deblank(matlabbatch{1}.spm.stats.fmri_spec.sess(j).scans{i});
    end

    % Conditions and regressors
    % -------------------------------------------------------------------------

    matlabbatch{1}.spm.stats.fmri_spec.sess(j).cond = struct('name', {}, 'onset', {}, 'duration', {}, 'tmod', {}, 'pmod', {}); % conditions
    
    %matlabbatch{1}.spm.stats.fmri_spec.sess(j).multi = {''}; % FILE NAME OF .MAT FILE?
    
    %matlabbatch{1}.spm.stats.fmri_spec.sess(j).regress = struct('name', {}, 'val', {});
    
    matlabbatch{1}.spm.stats.fmri_spec.sess(j).multi_reg = multi_nuisance_matfilenames(j); % is a cell % nuisance mat e.g. = '/.../reg.mat';
    
    
    % High-pass filter
    % -------------------------------------------------------------------------

    matlabbatch{1}.spm.stats.fmri_spec.sess(j).hpf = hpfilterlen; % CANLAB - *** specify
end

% Add onsets, etc. to conditions
% ---------------------------------------------------------------------
c = 1;

% add time modulation by default
for j = 1:length(images_by_run) % from run1 to the last run
    
    for k = 1:conditions_per_run(j)

        matlabbatch{1}.spm.stats.fmri_spec.sess(j).cond(k).name = names{c};
        matlabbatch{1}.spm.stats.fmri_spec.sess(j).cond(k).onset = onsets{c};
        matlabbatch{1}.spm.stats.fmri_spec.sess(j).cond(k).duration = durations{c};
        matlabbatch{1}.spm.stats.fmri_spec.sess(j).cond(k).tmod = timemod;  % time mod - default
        if length(pmodstruct) == 0
            matlabbatch{1}.spm.stats.fmri_spec.sess(j).cond(k).pmod = pmodstruct;
        else
            matlabbatch{1}.spm.stats.fmri_spec.sess(j).cond(k).pmod = pmodstruct{c};
        end
        % 'tmod', {}, 'pmod', {}); % conditions
        
        c = c + 1;
        
    end
    
end



% Factorial
% -------------------------------------------------------------------------

matlabbatch{1}.spm.stats.fmri_spec.fact = struct('name',{}, 'levels', {});
% matlabbatch{1}.spm.stats.fmri_spec.fact(1).name = 'Fam';
% matlabbatch{1}.spm.stats.fmri_spec.fact(1).levels = 2;
% matlabbatch{1}.spm.stats.fmri_spec.fact(2).name = 'Rep';
% matlabbatch{1}.spm.stats.fmri_spec.fact(2).levels = 2;

% Basis set
% -------------------------------------------------------------------------

matlabbatch{1}.spm.stats.fmri_spec.bases = bases; % LUKA - left CANLAB default (hrf, no derivs), but allows hrf+derivatives or fir
matlabbatch{1}.spm.stats.fmri_spec.volt = 1; % CANLAB - WE DO NOT WANT VOLTERRA; 1:none, 2:interactions

% Global signal and masking
% -------------------------------------------------------------------------

matlabbatch{1}.spm.stats.fmri_spec.global = 'None';         % CANLAB - WE DO NOT WANT GLOBAL
mask = which('brainmask.nii');                              % CANLAB - WE WANT WHOLE-BRAIN EXPLICIT MASK, NOT IMPLICIT
matlabbatch{1}.spm.stats.fmri_spec.mask = {[mask,',1']};
matlabbatch{1}.spm.stats.fmri_spec.cvi = cvi;               % CANLAB DEFAULT - WE DO NOT WANT AR MODEL (options allow AR(1))


% Add Estimate Job
% -------------------------------------------------------------------------

matlabbatch{2}.spm.stats.fmri_est.spmmat(1) = cfg_dep;
matlabbatch{2}.spm.stats.fmri_est.spmmat(1).tname = 'Select SPM.mat';
matlabbatch{2}.spm.stats.fmri_est.spmmat(1).tgt_spec = {struct('name',{'filter', 'strtype'},'value',{'mat','e'})};

matlabbatch{2}.spm.stats.fmri_est.spmmat(1).sname = 'fMRI model specification: SPM.mat File';
matlabbatch{2}.spm.stats.fmri_est.spmmat(1).src_exbranch = substruct('.','val', '{}',{1}, '.','val', '{}',{1}, '.','val', '{}',{1});
matlabbatch{2}.spm.stats.fmri_est.spmmat(1).src_output = substruct('.','spmmat');
matlabbatch{2}.spm.stats.fmri_est.method.Classical = 1;

end % function
