function [SMap, CPMap, CNTMap, TWidMap, W1Map, W2Map, W3Map, Tsq] = ewma2(X, lambda , L, type);%% EWMA - Exponentially Weighted Moving Average for fMRI slice%% Martin Lindquist 09/16/05%%% INPUTS %% X - Data over one slice (N x N x T data matrix)% lambda - smoothing factor% L - width of control limits% type - Type of noise model - White Noise: 'WN', AR(1): 'AR', AR+WN:% 'ARMA'%% OUTPUTS%% SMap - Significance Map% CPMap - Changepoint Map% CNTMap - Map that depicts the number of times the process is% out-of-control% TWidMap - map of total number of points out-of-control (all runs)% W1Map - map of number of points out-of-control in first run% W2Map - map of number of points out-of-control in second run% W3Map - map of number of points out-of-control in third run% Tsq - Squared, normalized data set for multi-subject analysis% Read-off dimensions of input datadim = size(X);if (length(dim) == 3),    N = dim(1);    V = dim(2);        T = dim(3);    M = prod(dim(1:2));elseif (length(dim) == 2),    N = dim(1);    T = dim(2);    M=N;else,    error('Wrong Dimensions')end;XX = reshape(X,M,T);Z = zeros(M,T);ZIU = zeros(M,T);ZIL = zeros(M,T);tt = 60;                                      % Length of time prior to potential activation% Three noise cases: White noise, AR(1) and ARMA(1,1)switch type        case 'WN'    fprintf(1,'White noise.');    mu = mean(XX(:,1:tt),2);            % Calculate in-control process mean	sigma = std(XX')';      % Calculate process standard deviation	CL = L*sigma*sqrt(lambda/(1-lambda))*sqrt(1-(1-lambda).^(2*(1:T)));               % Calculate control limits			Z(:,1) = mu;	for i=2:T, Z(:,i) = lambda*XX(:,i) + (1-lambda)*Z(:,(i-1)); end;        % Calculate EWMA statistic		ZIU(Z-(mu*(1+zeros(1,T))) > CL) = 1;          % 0-1 Matrix of points above upper control limit  	ZIL(Z-(mu*(1+zeros(1,T))) < -CL) = 1;         % 0-1 Matrix of points below lower control limit                     case 'AR'    fprintf(1,'AR(1).');	Phi = zeros(M,1);	sigma = zeros(M,1);	CL = zeros(M,T);	mu = mean(XX(:,1:tt),2); 		for h=1:(M),                [a,e] = aryule((XX(h,1:tt)-mu(h)),1);       % Estimate noise parameters using Yule-Walker Estimation        Phi(h) = a(2);        sigma(h) = sqrt(e);                % Calculate Control Limits                phi = a(2);        s = sigma(h);        if (abs(phi) > 1), warning('Current time course not causal'); end;        gamma0 = s^2*(1/(1 - phi^2));        gamma1 = s^2*(phi/(1 - phi^2));                pt1 = (1-(1-lambda).^(2*(1:T)))/(lambda*(2-lambda));        pt2 = (2*lambda/(2-lambda))*(1-lambda)/(1-phi*(1-lambda))*(1-(1-lambda).^(2*(1:T)-2));        pt3 = ((2*lambda^2)/(phi-(1-lambda)))*(1/(1-phi*(1-lambda))).*((phi*(1-lambda)).^(1:T)).*(1-((1-lambda)/phi).^((1:T)-1));        CL(h,:) = L*s*sqrt((gamma0*pt1 + gamma1*pt2 - gamma1*pt3));               % Calculate control limits		end;        Z(:,1) = mu;	for i=2:T, Z(:,i) = lambda*XX(:,i) + (1-lambda)*Z(:,(i-1)); end;        % Calculate EWMA statistic		ZIU(Z-(mu*(1+zeros(1,T))) > CL) = 1;          % 0-1 Matrix of points above upper control limit  	ZIL(Z-(mu*(1+zeros(1,T))) < -CL) = 1;         % 0-1 Matrix of points below lower control limit      case 'ARMA'        fprintf(1,'ARMA(1,1).');	Phi = zeros(M,1);    Theta  = zeros(M,1);	sigma = zeros(M,1);	CL = zeros(M,T);	mu = mean(XX(:,1:tt),2);     	for h=1:(M),                m=armax(XX(h,1:tt)',[1 1]);                  % Estimate noise parameters            Phi(h) = -m.A(2);        Theta(h) = m.C(2);                sigma(h) = sqrt(m.NoiseVariance);            % Calculate Control Limits                phi = Phi(h);        theta = Theta(h);        s = sigma(h);                if (abs(phi) > 1), warning('Current time course not causal'); end;                gamma0 = s^2*(1+ (theta + phi)^2/(1 - phi^2));        gamma1 = s^2*(theta + phi + phi*(theta + phi)^2/(1 - phi^2));                pt1 = (1-(1-lambda).^(2*(1:T)))/(lambda*(2-lambda));        pt2 = (2*lambda/(2-lambda))*(1-lambda)/(1-phi*(1-lambda))*(1-(1-lambda).^(2*(1:T)-2));        pt3 = ((2*lambda^2)/(phi-(1-lambda)))*(1/(1-phi*(1-lambda))).*((phi*(1-lambda)).^(1:T)).*(1-((1-lambda)/phi).^((1:T)-1));        CL(h,:) = L*s*sqrt((gamma0*pt1 + gamma1*pt2 - gamma1*pt3));               % Calculate control limits		end;        Z(:,1) = mu;	for i=2:T, Z(:,i) = lambda*XX(:,i) + (1-lambda)*Z(:,(i-1)); end;        % Calculate EWMA statistic		ZIU(Z-(mu*(1+zeros(1,T))) > CL) = 1;          % 0-1 Matrix of points above upper control limit  	ZIL(Z-(mu*(1+zeros(1,T))) < -CL) = 1;         % 0-1 Matrix of points below lower control limit             case 'AR(2)',         fprintf(1,'AR(2).');	Phi1 = zeros(M,1);    Phi2 = zeros(M,1);	sigma = zeros(M,1);	CL = zeros(M,T);	mu = mean(XX(:,1:tt),2); 	% find non-empty timecourses    wh = all(XX' - repmat(mean(XX'),size(XX,2),1) <= eps) | any(isnan(XX),2)';    wh = find(~wh);    if isempty(wh), disp('Note: Empty slice.'),end    	for h=wh        [a,e] = aryule((XX(h,1:tt)-mu(h)),2);       % Estimate noise parameters using Yule-Walker Estimation        Phi1(h) = a(2);                Phi2(h) = a(3);        sigma(h) = sqrt(e);                % Calculate Control Limits                s = sigma(h);        w = roots(a(3:-1:1));                C = ((s*w(1)*w(2))^2)/((w(1)*w(2)-1)*(w(2)-w(1)));        A1 = C*(w(1)/(w(1)^2-1));        A2 = -C*(w(2)/(w(2)^2-1));        gamma0 = A1 + A2;        pt1 = lambda*(1-(1-lambda).^(2*(1:T)))/((2-lambda));        pt2 = 2*lambda^2*A1*w(1)/(w(1)-(1-lambda))*((1-lambda)/(w(1)*lambda*(2-lambda))*(1-(1-lambda).^(2*(1:T)-2))-(((1-lambda)/w(1)).^(1:T)).*(1-((1-lambda)*w(1)).^((1:T)-1))/(1-(1-lambda)*w(1)));            pt3 = 2*lambda^2*A2*w(2)/(w(2)-(1-lambda))*((1-lambda)/(w(2)*lambda*(2-lambda))*(1-(1-lambda).^(2*(1:T)-2))-(((1-lambda)/w(2)).^(1:T)).*(1-((1-lambda)*w(2)).^((1:T)-1))/(1-(1-lambda)*w(2)));                    CL(h,:) = L*real(sqrt((gamma0*pt1 + pt2 + pt3)));               % Calculate control limits		end;        Z(:,1) = mu;	for i=2:T, Z(:,i) = lambda*XX(:,i) + (1-lambda)*Z(:,(i-1)); end;        % Calculate EWMA statistic		ZIU(Z-(mu*(1+zeros(1,T))) > CL) = 1;          % 0-1 Matrix of points above upper control limit  	ZIL(Z-(mu*(1+zeros(1,T))) < -CL) = 1;         % 0-1 Matrix of points below lower control limit                        otherwise        error('Unknown error model type.')end;    % % Estimate Changepoints% % % m = zeros(M,T);        % % for j =1:(T-1), % %     m(:,j) = (T-j)*(sum(XX(:,(j+1):T),2)/(T-j) - mu).^2; % % end;% % % % [a,b] = max(m');                         % Find MLE of changepoint for all voxels% % CP = b.*(mean(ZIU,2) > 0)';         % Only keep MLEs for out-of control processes% % % % m = zeros(M,T);        % % for j =2:(T-1), % %     m(:,j) = sqrt((j*(T-j))/T)*(sum(XX(:,1:j),2)/j - sum(XX(:,(j+1):T),2)/(T-j))./sqrt( (std(XX(:,1:j)').^2)/j + (std(XX(:,(j+1):T)').^2)/(T-j))'; % % end;% % % % [a,b] = max(m');                        % % CP = b.*(mean(ZIU,2) > 0)';         % % Estimation via Zero-crossingsCP2 = zeros(M,1);CNTmat  = zeros(M,1);TOTmat = zeros(M,1);LENmat = zeros(M,T);for d=1:M,        % Calculate last 'zero-crossing'        dat = Z(d,:)-mu(d);    tmp = ZIU(d,:);    [a,b] = max((conv([1 1 1],tmp) == 3));    [a,zc] = max((dat(1:b) < 0).*(1:b));    CP2(d) = zc;        % Calculate number of out-of-control runs and their widths        [cnt tot len] = cnt_runs(tmp);    CNTmat(d) = cnt;    TOTmat(d) = tot;    LENmat(d,:) = len';end;% Define all relevant mapswarning offSMap = reshape(max((L.*(Z- repmat(mu,1,T))./CL)')',N,V);            % Significance MapCPMap = reshape(CP2,N,V);                                           % Changepoint MapCNTMap = reshape(CNTmat,N,V);                                       % Map that depicts the number of times the process is out-of-controlTWidMap = reshape(TOTmat,N,V);                                      % TWidMap - map of total number of points out-of-control (all runs)W1Map = reshape(LENmat(:,1),N,V);                                   % W1Map - map of number of points out-of-control in first runW2Map = reshape(LENmat(:,2),N,V);                                   % W2Map - map of number of points out-of-control in second runW3Map = reshape(LENmat(:,3),N,V);                                   % W3Map - map of number of points out-of-control in third runTsq = (Z.^2)/((CL(end)/L)^2);                                       % Tsq - Squared, normalized data set for multi-subject analysis% Plot all relevant mapsdoplot = 1;if doplot subplot(2,4,1)imagesc(SMap);subplot(2,4,2)imagesc(CPMap);subplot(2,4,3)imagesc(CNTMap);subplot(2,4,4)imagesc(TWidMap);subplot(2,4,5)imagesc(W1Map);subplot(2,4,6)imagesc(W2Map);subplot(2,4,7)imagesc(W3Map);drawnowendreturn;